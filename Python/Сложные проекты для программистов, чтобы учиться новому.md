### [Главная][1]

# Сложные проекты для программистов, чтобы учиться новому

## Это список в стиле серии [Challenging projects every programmer should try](https://austinhenley.com/blog/morechallengingprojects.html) Остина Хенли.

### Создать поисковый краулер

Краулер — это бот, ходящий по веб-страницам и сохраняющий их содержимое. Краулеры используются поисковыми движками для исследования веба. Содержимое веб-страниц «индексируется». Это означает, что страницы куда-то сохраняются для дальнейшего поиска по ним.

Я решил создать поисковый движок для небольшого сообщества, в котором участвую. Сообществу был известен список из примерно тысячи сайтов, составленный людьми, делающими вклад в общую wiki. Я использовал его как список для краулинга. Вы можете составить собственный список сайтов и написать свой поисковый движок. Допустим, можно сделать поисковый движок по своим любимым аниме-блогам. Или фан-сайтам Тейлор Свифт. Всего, чего угодно, если только это есть в вебе.

Самым важным открытием для меня в этом процессе стало то, что веб — это Дикий Запад. Никогда нельзя ожидать, что чья-то веб-страница будет именно такой, какая нужна вам. Создание поискового краулера — это упражнение, обучающее нас надёжным образом получать максимально возможное количество веб-сайтов, и чтобы при этом сайты не валились.

При создании поискового краулера вы узнаете:

1. Как скачивать веб-страницу

2. Стандарты краулинга контента (robots.txt, тэги meta «взрослого» контента)

3. Об ограничениях частоты опросов

4. Об экспоненциальных выдержках

5. Когда выполнять краулинг и повторный краулинг сайтов

6. О content negotiation

7. Об Etag

8. И обо многом другом

Веб и в самом деле Дикий Запад. Но у этого Дикого Запада есть множество восхитительных технически сложных задач, которые можно решить. Эта задача занимала мой мозг несколько месяцев. Хотя мой поисковый движок уже неактивен, этот проект придал мне уверенности в том, что я могу сделать нечто большее, чем написание крошечных скриптов на Python.

### Создать систему автоматического завершения

Представьте, что вы пишете пост для блога. Как можно автоматически завершать слова на основании последовательности букв? Возьмём для примера эту статью. Если я начал слово с «экспонен», то как можно эффективно предложить «экспоненциальных» в качестве готового слова? В этом и заключается сложность. Я не буду подробно рассказывать о внутреннем устройстве этого проекта, но при его создании я получил много удовольствия!

Когда поймёшь, как автоматически завершать слова, возникает ещё одна сложность: как рекомендовать, какое слово завершать автоматически. Если я введу «экспоне», то как алгоритм автоматического завершения узнает, рекомендовать ли «экспонента» или «экспоненциальных»?

### Нaписать программу для сжатия файлов

Существует множество замечательных инструментов, сжимающих файлы, но задавались ли вы когда-нибудь вопросом, как они уменьшают эти файлы?

Вот вам задание: скачайте [оригинал статьи](https://jamesg.blog/2024/02/28/programming-projects/) как файл HTML. Напишите программу, создающую сжатую версию файла HTML. Ваша программа должна уметь воспроизводить файл в точности. Всё должно остаться таким же, включая пробелы и заглавные буквы.

Вот некоторые из тем, которые могут вам пригодиться в изучении этой области (хотя если вам интересна эта задача, то рекомендую попробовать написать программу сжатия, не читая особо много об этом!):

* Теория информации;

* Метод сжатия с использованием словаря (способ описания информации);

* Код Хаффмана (популярный алгоритм сжатия);

* Энтропия (мера величины «информации» в файле; «информация» намеренно поставлена в кавычки).

### Реализовать BitCask

[BitCask](https://riak.com/assets/bitcask-intro.pdf) — это алгоритм хранения ключей и значений. Хранилища ключей и значений сопоставляют ключи (имена) с значениями (блоками информации). Например, я бы мог хранить информацию о постах в своём блоге так:

```
{"title": "(Even more) challenging programming projects you should try", "published": "2024-02-28"}
```

Где title и published — это имена, связанные со значениями.

BitCask работает только с использованием вашей файловой системы. Ключи и значения сохраняются в файлы. В каждый файл можно только добавлять информацию. Можно удалять ключи, но при этом переопределяется старый ключ, а не явным образом удаляется значение. [Документация по BitCask — это короткая и полезная статья](https://riak.com/assets/bitcask-intro.pdf), помогавшая мне при реализации алгоритма. Задача для вас:

1. Создать cask (хранилище ключей и значений на основе алгоритма BitCask)

2. Добавить элементы в cask

3. Извлечь элементы из cask

4. Удалить элементы из cask

5. Закрыть cask

При закрытии cask выполняется операция слияния, объединяющая все файлы cask в один.

### Написать язык программирования

*Ого, ничего себе! Язык программирования? Только серьёзные специалисты способны на такое!* Я тоже так думал. Но оказалось, что это неправда! Вы тоже можете создать язык программирования. И прежде чем приступить к этому, даже не нужно читать сотни страниц литературы по теории (однако чем больше вы читаете, тем больше информации у вас будет для проектирования своего языка!).

Проектирование языка программирования позволяет вам решать, как именно вы хотите писать код. Можно воспользоваться готовыми паттернами или придумать собственный. Правила пишете вы сами.

Существует множество типов языков программирования, но лучше всего начать с написания языка, не требующего компилятора. Возможно, я пристрастен, потому что сам так учился, но мысль о необходимости писать компилятор, прежде чем у меня появится чуть больше опыта в теории языков программирования, казалась мне пугающей. Поэтому я написал «интерпретируемый» язык. Файл считывается, парсится, затем исполняется; никакой компиляции.

Интерпретируемый язык состоит из нескольких основных элементов:

1. «Грамматики», определяющей структуру языка;

2. «Лексического анализатора»/«парсера», получающего произвольный текст (например, скрипт, написанный на вашем языке!) и превращающего его в абстрактное синтаксическое дерево (Abstract Syntax Tree, AST) на основании вашей грамматики;

3. Системы символьных выражений, считывающей синтаксическое дерево и выполняющей с ней какие-то операции.

Каждый из перечисленных выше трёх компонентов представляет собой отдельную техническую сложность. Я рекомендую начинать с написания грамматики и парсера. Ваша грамматика будет определять, как работает язык (то есть как объявлять переменные, список разрешённых и запрещённых символов, то, как работает или не работает вложенность). Для интерпретации грамматики можно использовать готовый лексический анализатор. Я воспользовался Lark для Python. Система символьных выражений будет брать синтаксическое дерево и применять логику программы (то есть хранить переменные, выполнять математические вычисления, работать со строками и булевыми значениями и делать всё то, что вы захотите от языка).

[Оригинал статьи](https://habr.com/ru/articles/797591/)

### [Главная][1]

[1]: /knowledge-base/